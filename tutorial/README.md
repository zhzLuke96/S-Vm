# lambda

# f.x.x
欧耶，完事~

就是这么简单，要学会一眼看到底，你才抓得住lambda的真谛

# f.x.f(x)
替换！绑定的不换！

遗留问题：自由变量并不能判断，这个暂时忽略

# f.x.f(f(x))
函数，调用就是替换！

遗留问题：由于function被设置为不可规约的，在function中的call将不会被简化，这也是由于我们省略了自由变量产生的

# f.x.f(f(f(x)))
interpreter:

    这么简单的东西就不用库了
    （其实就是懒得,用库的话会有很多很多好处，非常麻烦的智能检查和语法提示，要手写的话，还是有点不爽不爽。因此这里也就不写了）
    其实对象行为都定义好了，解释器就是一个翻译流程变成代码的过程

    我这里的解释器基本分作三块：拍散（tokenize），层次化（parse_token），标记为对象（sign）

    流水线看上去是这样的=>
    eval_lamb := __TOKEN__ |> tokenize |> parse_token |> sign

    INPUT : (x.(y.(x y)))
    => ['(', 'x', '.', '(', 'y', '.', '(', 'x', 'y', ')', ')', ')']
    => ['x', '.', ['y', '.', ['x', 'y']]]
    => <object> (<object>.toString() => (x.(y.(x y))))

# f.x.f(f(f(f(x))))
解决遗留问题

变量搞毛线？
