# lambda

# f.x.x
欧耶，完事~

就是这么简单，要学会一眼看到底，你才抓得住lambda的真谛

# f.x.f(x)
替换！绑定的不换！

遗留问题：自由变量并不能判断，这个暂时忽略

# f.x.f(f(x))
函数，调用就是替换！

遗留问题：由于function被设置为不可规约的，在function中的call将不会被简化，这也是由于我们省略了自由变量产生的

# f.x.f(f(f(x)))
interpreter:

    这么简单的东西就不用库了
    （其实就是懒得,用库的话会有很多很多好处，非常麻烦的智能检查和语法提示，要手写的话，还是有点不爽不爽。因此这里也就不写了）
    其实对象行为都定义好了，解释器就是一个翻译流程变成代码的过程

    我这里的解释器基本分作三块：拍散（tokenize），层次化（parse_token），标记为对象（sign）

    流水线看上去是这样的=>
    eval_lamb := __TOKEN__ |> tokenize |> parse_token |> sign

    INPUT : (x.(y.(x y)))
    => ['(', 'x', '.', '(', 'y', '.', '(', 'x', 'y', ')', ')', ')']
    => ['x', '.', ['y', '.', ['x', 'y']]]
    => <object> (<object>.toString() => (x.(y.(x y))))

# f.x.f(f(f(f(x))))
变量搞毛线？

解决遗留问题

    function的规约，我们直接开启试试看会如何
    => ((x.(p.(x.(p ((x p) x))))) (p.(x.(p x))))
    这条之前为化解的句子(p.(x.(p (((p.(x.(p x))) p) x))))
    被错误的化解成了 (p.(x.(p ((x p) x))))

    太长了我们简单点看问题所在
    (((p.(x.(p x))) p) x) => ((x p) x)
    (((p.(x.(p x))) p) x) => (p x)
    什么鬼啊！多出来了还行

    好吧其实不是这里的问题，我们看整个过程，
    ((x.((n.(p.(x.(p ((n p) x))))) x)) (p.(x.(p x))))
    这句里有两个x.也就是两个lambda绑定了变量x，但是其实，其中有一点局部变量的意思，即应该是这样
    ((x.((n.(p.(x1.(p ((n p) x1))))) x)) (p1.(x2.(p1 x2))))

    翻译成过程就是，function中每个重名的绑定变量都重命名新名字
    耶，撒花~
    等等！
    (x.y) m这里面的m咋办？没在function里面的？对啊！
    f((x.x(f x))) x => x.(x(x x))明显是错误的，也要改名！

    走你，自由变量改为f，绑定变量改为b，加上计数器
